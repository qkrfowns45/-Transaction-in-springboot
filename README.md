# Transaction-in-springboot
## springboot의 전통적인 트랜잭션과 격리수준
### 트랜잭션
> 일이 처리되는 가장 작은 단위이다.

### 트랜잭션의 격리 수준
>동시에 여러 트랜잭션이 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할 지 말지를 결정하는 것

### 트랜잭션의 격리 수준 목록
+ READ UNCOMMITTED
+ READ COMMITTED
+ REPEATABLE READ
+ SERIALIZABLE

### READ UNCOMMITTED
+ 각 트랜잭션에서의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관 없이 다른 트랜잭션에서 값을 읽을 수 있다.
+ 정합성에 문제가 많은 격리 수준이기 때문에 사용하지 않는 것을 권장한다.
> 문제점 발생
+ 트랜잭션이 작업이 완료되지 않았음에도 다른 트랜잭션에서 볼 수 있게 되는 현상( DIRTY READ )

### READ COMMITTED
+ RDB에서 대부분 기본적으로 사용되는 격리수준이다(ex.oracle)
+ Dirty Read와 같은 현상은 발생하지 않는다.
+ 실제 테이블 값을 가져오는 것이 아니라 Undo 영역에 백업된 레코드에서 값을 가져온다.
> 문제점 발생
+ 하나의 트랜잭션내에서 똑같은 SELECT쿼리를 실행했을 때 항상 같은 결과를 가져와야 하는데 REPEATABLE READ의 정합성에 어긋남
> (주로 입금, 출금 처리가 진행되는 금전적인 처리에서 주로 발생한다. 데이터의 정합성은 깨지고, 버그는 찾기 어려워진다.)

### REPEATABLE READ
+ MySQL에서는 트랜잭션마다 트랜잭션 ID를 부여하여 트랜잭션 ID보다 작은 트랜잭션 번호에서 변경한 것만 읽게 된다.
+ Undo 공간에 백업해두고 실제 레코드 값을 변경한다.
  + 백업된 데이터는 불필요하다고 판단하는 시점에 주기적으로 삭제한다.
  + Undo에 백업된 레코드가 많아지면 MySQL 서버의 처리 성능이 떨어질 수 있다.
> 문제점 발생
+ 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안 보였다가 하는 현상이 발생한다.(PHANTOM READ)
+ 이를 방지하기 위해서는 쓰기 잠금을 걸어야한다.

### SERIALIZABLE
+ 가장 단순한 격리 수준이지만 가장 엄격한 격리 수준
+ 성능 측면에서는 동시 처리성능이 가장 낮다.
+ SERIALIZABLE에서는 PHANTOM READ가 발생하지 않는다.하지만 데이터베이스에서 거의 사용되지 않는다.

### 스프링 부트의 전통적인 트랜잭션
> 스프링 시작 -> 톰캣 시작(서버 작동) ->web.xml -> context.xml -> DB 연결 테스트
> 이때 request가 일어나면 web.xml(DB 연결 세션 생성 -> 트랜잭션 시작) -> filter -> controller(요청 분기 -> 서비스 호출)
> -> DB를 조회하여 영속성 컨텍스트에 넣는다 -> 트랜잭션에 있는 모든 SUDI를 진행한다(영속성 컨텍스트 값이 변경되기도함)
> -> 트랜잭션을 종료시키고 변경을 감지하여 flush를 진행한다. -> db연결 세션 종료한다.
> -> 그 후 비동기면 data 동기면 html을 응답한다.
